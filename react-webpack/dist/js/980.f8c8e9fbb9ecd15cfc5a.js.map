{"version":3,"file":"js/980.f8c8e9fbb9ecd15cfc5a.js","mappings":"shCAGqBA,EAAAA,SAAAA,I,6rBAEnB,WAAaC,GAAO,a,4FAAA,UAElB,cAAMA,IAIDC,MAAQ,CACXC,MAAO,IACPC,IAAK,IACLC,IAAK,cAKPC,QAAQC,IAAI,mBAdM,E,8CAiBpB,WAIED,QAAQC,IAAI,2B,mCAGd,SAAuBN,EAAOC,GAO5B,OAAIM,KAAKN,MAAME,MAAQF,EAAME,M,gCAQ/B,SAAoBH,EAAOC,GAOrBA,EAAMC,MAIVG,QAAQC,IAAI,4B,kCAGd,WAIED,QAAQC,IAAI,8B,wBAGd,WAGE,OAAO,oC,yBAGT,WACEC,KAAKC,UAAS,SAAAP,GACZ,MAAO,CACLC,MAAOD,EAAMC,MAAQ,Q,uBAK3B,WACEK,KAAKC,UAAS,SAAAP,GAAK,MAAG,CAACE,IAAKF,EAAME,IAAM,Q,oBAK1C,WAAU,WAMAD,EAAUK,KAAKN,MAAfC,MAER,OADAG,QAAQC,IAAI,cAEV,2BACE,oCACA,0BAAMJ,GACN,0BAAQO,QAAS,kBAAI,EAAKC,gBAA1B,MACA,0BAAQD,QAAS,kBAAI,EAAKE,cAA1B,MACEJ,KAAKK,mB,sEAhGMb,CAAkBc,EAAAA","sources":["webpack:///./src/views/12/StudyLife.jsx"],"sourcesContent":["import React, { Component, PureComponent } from 'react'\n\n\nexport default class StudyLife extends Component {\n\n  constructor (props) {\n    // 调用父类的构造器函数，必须是constructor的第一行代码\n    super(props)\n    // 定义声明式变量（先定义再使用）\n    // 强调：声明式变量常用的数据类型，基本数据类型、对象、数组\n    // 在定义state，必须和props独立开来，不要交叉赋值\n    this.state = {\n      count: 100,\n      num: 200,\n      msg: 'Hello Life'\n    }\n    // 在这里可以编写一些初始化业务逻辑\n    // 但不要在这里调接口、不要开定时器等\n    // 也不能使用 this.setState()\n    console.log('----constructor')\n  }\n\n  componentDidMount () {\n    // 相当于vue中的mounted，表示初始化视图渲染已完成\n    // 在这里，你可编写任何你想要的业务逻辑：调接口、开定时器、DOM操作、ref操作等。\n    // 在这里，还可以使用 this.setState()，触发进入更新阶段。\n    console.log('----componentDidMount')\n  }\n\n  shouldComponentUpdate (props, state) {\n    // 这是一个“开关”，只要编写了这个生命周期，它必须得返回一个布尔值\n    // 当它返回true时，组件将正常执行更新阶段\n    // 当它返回false时，到这儿就结束了，不再执行后续的更新阶段了\n    // 这玩意有什么用？这是React最早的时候留给我们一个用于性能优化的方案。\n    // 因为这个生命周期比较难用，后来React提供了一个叫 PureComponent 的组件，帮助我们实现了shouldComponentUpdate()相似的功能。所以我们定义类组件时，继承自 PureComponent，就没必要再使用 shouldComponentUpdate了。\n\n    if (this.state.num !== state.num) {\n      return false\n    } else {\n      return true\n    }\n    console.log('----shouldComponentUpdate')\n  }\n\n  componentDidUpdate (props, state) {\n    // 相当于vue中的updated，表示视图已更新完成\n    // 特别说明：这个生命周期等价于 this.setState({}|fn, callback) 的第二个回调函数\n    // 结论：一般很少使用this.setState()的第二个回调函数，建议使用这个生命周期来替代\n    // 注意：在这里是可以编写业务逻辑的，比如DOM操作、调接口等。\n    // 注意：在这里，还可以使用 this.setState() ，但必须给终止条件。就像给 while循环添加终止条件一样。\n    // 在某种程度上，这个功能有点像vue中的watch功能。\n    if (state.count < 110) {\n      // 一定要有终止条件\n      // this.setState(state=>({count: state.count + 1}))\n    }\n    console.log('----componentDidUpdate')\n  }\n\n  componentWillUnmount () {\n    // 相当于vue中的beforeDestroy，表示组件即将被销毁\n    // 在这里，可以清缓存、清除定时器等。\n    // 在这里，不能 this.setState()，也没有必要执行DOM功能。\n    console.log('----componentWillUnmount')\n  }\n\n  renderName () {\n    // do something\n    // this.setState(state=>({count: state.count + 1}))\n    return <h1>我的名义</h1>\n  }\n\n  changeCount () {\n    this.setState(state=>{\n      return {\n        count: state.count + 1\n      }\n    })\n  }\n\n  changeNum () {\n    this.setState(state=>({num: state.num + 1}))\n  }\n\n\n\n  render () {\n    // 是所有生命周期函数中唯一的一个必须要有的生命周期\n    // 也就是说，一个类组件必须得有 render()，它的返回值是视图结构（JSX、Fiber树）\n    // 初始化时render()会执行，当this.setState()时也会执行render()\n    // 特别注意：在render()函数的作用域内，不能调用 this.setState()，特别小心。\n    // 说明：在render()可以处理数据，但不要执行调接口、定时器、DOM操作。\n    const { count } = this.state\n    console.log('----render')\n    return (\n      <div>\n        <h1>学习生命周期</h1>\n        <h1>{ count }</h1>\n        <button onClick={()=>this.changeCount()}>自增</button>\n        <button onClick={()=>this.changeNum()}>测试</button>\n        { this.renderName() }\n      </div>\n    )\n  }\n}\n"],"names":["StudyLife","props","state","count","num","msg","console","log","this","setState","onClick","changeCount","changeNum","renderName","Component"],"sourceRoot":""}